{"version":3,"file":"question_engine.min.js","sources":["../src/question_engine.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * JavaScript required by the question engine.\r\n *\r\n * @module     core_question/question_engine\r\n * @copyright  2021 The Open University\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport * as scrollManager from 'core/scroll_manager';\r\nimport * as formSubmit from 'core_form/submit';\r\n\r\n/**\r\n * Initialise a question submit button. This saves the scroll position and\r\n * sets the fragment on the form submit URL so the page reloads in the right place.\r\n *\r\n * @param {string} button the id of the button in the HTML.\r\n */\r\nexport const initSubmitButton = button => {\r\n    formSubmit.init(button);\r\n    scrollManager.watchScrollButtonSaves();\r\n};\r\n\r\n/**\r\n * Allow check button to pass value to form.\r\n *\r\n * @param {string} elementId the id of the button in the HTML.\r\n */\r\nexport const initCheckButton = elementId => {\r\n    const button = document.getElementById(elementId);\r\n    button.addEventListener('click', function(event) {\r\n        document.getElementById(\"checkedslot\").value = event.target.dataset.slot;\r\n    });\r\n};\r\n\r\n/**\r\n * Focus the feedback.\r\n */\r\nexport const focusFeedback = () => {\r\n    // Wait for the window to load, then focus the feedback.\r\n    window.onload = function() {\r\n        let describedfeedback = document.getElementById(\"describedfeedback\");\r\n        if (describedfeedback) {\r\n            describedfeedback.focus();\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Initialise a form that contains questions printed using print_question.\r\n * This has the effect of:\r\n * 1. Turning off browser autocomlete.\r\n * 2. Stopping enter from submitting the form (or toggling the next flag) unless\r\n *    keyboard focus is on the submit button or the flag.\r\n * 3. Removes any '.questionflagsavebutton's, since we have JavaScript to toggle\r\n *    the flags using ajax.\r\n * 4. Scroll to the position indicated by scrollpos= in the URL, if it is there.\r\n * 5. Prevent the user from repeatedly submitting the form.\r\n *\r\n * @param {string} formSelector Selector to identify the form.\r\n */\r\nexport const initForm = (formSelector) => {\r\n    const form = document.querySelector(formSelector);\r\n    form.setAttribute('autocomplete', 'off');\r\n\r\n    form.addEventListener('submit', preventRepeatSubmission);\r\n\r\n    form.addEventListener('key', (event) => {\r\n        if (event.keyCode !== 13) {\r\n            return;\r\n        }\r\n\r\n        if (event.target.matches('a')) {\r\n            return;\r\n        }\r\n\r\n        if (event.target.matches('input[type=\"submit\"]')) {\r\n            return;\r\n        }\r\n\r\n        if (event.target.matches('input[type=img]')) {\r\n            return;\r\n        }\r\n\r\n        if (event.target.matches('textarea') || event.target.matches('[contenteditable=true]')) {\r\n            return;\r\n        }\r\n\r\n        event.preventDefault();\r\n    });\r\n\r\n    const questionFlagSaveButtons = form.querySelectorAll('.questionflagsavebutton');\r\n    [...questionFlagSaveButtons].forEach((node) => node.remove());\r\n\r\n    // Note: The scrollToSavedPosition function tries to wait until the content has loaded before firing.\r\n    scrollManager.scrollToSavedPosition();\r\n};\r\n\r\n/**\r\n * Event handler to stop a question form being submitted more than once.\r\n *\r\n * @param {object} event the form submit event.\r\n */\r\nexport const preventRepeatSubmission = (event) => {\r\n    const form = event.target.closest('form');\r\n    if (form.dataset.formSubmitted === '1') {\r\n        event.preventDefault();\r\n        return;\r\n    }\r\n\r\n    setTimeout(() => {\r\n        [...form.querySelectorAll('input[type=submit]')].forEach((input) => input.setAttribute('disabled', true));\r\n    });\r\n    form.dataset.formSubmitted = '1';\r\n};\r\n"],"names":["button","formSubmit","init","scrollManager","watchScrollButtonSaves","elementId","document","getElementById","addEventListener","event","value","target","dataset","slot","window","onload","describedfeedback","focus","formSelector","form","querySelector","setAttribute","preventRepeatSubmission","keyCode","matches","preventDefault","querySelectorAll","forEach","node","remove","scrollToSavedPosition","closest","formSubmitted","setTimeout","input"],"mappings":";;;;;;;+TAgCgCA,SAC5BC,WAAWC,KAAKF,QAChBG,cAAcC,mDAQaC,YACZC,SAASC,eAAeF,WAChCG,iBAAiB,SAAS,SAASC,OACtCH,SAASC,eAAe,eAAeG,MAAQD,MAAME,OAAOC,QAAQC,gCAO/C,KAEzBC,OAAOC,OAAS,eACRC,kBAAoBV,SAASC,eAAe,qBAC5CS,mBACAA,kBAAkBC,4BAkBLC,qBACfC,KAAOb,SAASc,cAAcF,cACpCC,KAAKE,aAAa,eAAgB,OAElCF,KAAKX,iBAAiB,SAAUc,yBAEhCH,KAAKX,iBAAiB,OAAQC,QACJ,KAAlBA,MAAMc,UAINd,MAAME,OAAOa,QAAQ,MAIrBf,MAAME,OAAOa,QAAQ,yBAIrBf,MAAME,OAAOa,QAAQ,oBAIrBf,MAAME,OAAOa,QAAQ,aAAef,MAAME,OAAOa,QAAQ,2BAI7Df,MAAMgB,yBAGsBN,KAAKO,iBAAiB,4BACzBC,SAASC,MAASA,KAAKC,WAGpD1B,cAAc2B,+BAQLR,wBAA2Bb,cAC9BU,KAAOV,MAAME,OAAOoB,QAAQ,QACC,MAA/BZ,KAAKP,QAAQoB,eAKjBC,YAAW,SACHd,KAAKO,iBAAiB,uBAAuBC,SAASO,OAAUA,MAAMb,aAAa,YAAY,QAEvGF,KAAKP,QAAQoB,cAAgB,KAPzBvB,MAAMgB"}