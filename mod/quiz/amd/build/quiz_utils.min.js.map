{"version":3,"file":"quiz_utils.min.js","sources":["../src/quiz_utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Render the question slot template for each question in the quiz edit view.\n *\n * @module     mod_quiz/quiz_utils\n * @copyright  2024 The Open University.\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {config} from 'mod_quiz/quiz_toolboxes';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {getString, getStrings} from 'core/str';\n\n// const allStrings = [\n//     {key: 'question', component: 'moodle'},\n//     {key: 'removepagebreak', component: 'quiz'},\n//     {key: 'addpagebreak', component: 'quiz'},\n//     {key: 'questiondependencyremove', component: 'quiz', },\n//     {key: '', component: ''},\n//     {key: '', component: ''},\n//     {key: '', component: ''},\n//     {key: '', component: ''},\n//     {key: '', component: ''},\n// ];\n// getStrings()\n\nconst slot = {\n    CSS: {\n        SLOT: 'slot',\n        QUESTIONTYPEDESCRIPTION: 'qtype_description',\n        CANNOT_DEPEND: 'question_dependency_cannot_depend'\n    },\n    CONSTANTS: {\n        SLOTIDPREFIX: 'slot-',\n        QUESTION: M.util.get_string('question', 'moodle')\n    },\n    SELECTORS: {\n        SLOT: 'li.slot',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'span.slotnumber',\n        PAGECONTENT: 'div#page-content',\n        PAGEBREAK: 'span.page_split_join_wrapper',\n        ICON: '.icon',\n        QUESTIONTYPEDESCRIPTION: '.qtype_description',\n        SECTIONUL: 'ul.section',\n        DEPENDENCY_WRAPPER: '.question_dependency_wrapper',\n        DEPENDENCY_LINK: '.question_dependency_wrapper .cm-edit-action',\n        DEPENDENCY_ICON: '.question_dependency_wrapper .icon'\n    },\n\n    /**\n     * Retrieve the slot item from one of its child Nodes.\n     *\n     * @method getSlotFromComponent\n     * @param slotComponent {Element} The component Node.\n     * @return {Element|null} The Slot Node.\n     */\n    getSlotFromComponent: function(slotComponent) {\n        return slotComponent.closest(this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Determines the slot ID for the provided slot.\n     *\n     * @method getId\n     * @param slot {Element} The slot to find an ID for.\n     * @return {Number|false} The ID of the slot in question or false if no ID was found.\n     */\n    getId: function(slot) {\n        // We perform a simple substitution operation to get the ID.\n        let id = slot.id.replace(\n            this.CONSTANTS.SLOTIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (typeof id === 'number' && isFinite(id)) {\n            return id;\n        }\n        return false;\n    },\n\n    /**\n     * Determines the slot name for the provided slot.\n     *\n     * @method getName\n     * @param slot {Element} The slot to find a name for.\n     * @return {string|null} The name of the slot in question or null if no name was found.\n     */\n    getName: function(slot) {\n        const instance = slot.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance) {\n            // ??\n            return instance.firstChild.data;\n        }\n        return null;\n    },\n\n    /**\n     * Determines the slot number for the provided slot.\n     *\n     * @method getNumber\n     * @param slot {Element} The slot to find the number for.\n     * @return {Number|false} The number of the slot in question or false if no number was found.\n     */\n    getNumber(slot) {\n        if (!slot) {\n            return false;\n        }\n        // We perform a simple substitution operation to get the number.\n        let number = slot.querySelector(this.SELECTORS.NUMBER).textContent.replace(\n            this.CONSTANTS.QUESTION, '');\n        // Attempt to validate the ID.\n        number = parseInt(number, 10);\n        if (!isNaN(number)) {\n            return number;\n        }\n        return false;\n    },\n\n    /**\n     * Updates the slot number for the provided slot.\n     *\n     * @method setNumber\n     * @param slot {Element} The slot to update the number for.\n     * @param number {Number} The slot number.\n     * @return void\n     */\n    setNumber(slot, number) {\n        let numberNode = slot.querySelector(this.SELECTORS.NUMBER);\n        numberNode.innerHTML = '<span class=\"accesshide\">' + this.CONSTANTS.QUESTION + '</span> ' + number;\n    },\n\n    /**\n     * Returns a list of all slot elements on the page.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getSlots() {\n        return document.querySelectorAll(this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL + ' ' + this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Returns a list of all slot elements on the page that have numbers. Excudes description questions.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getNumberedSlots() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')';\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Returns the previous slot to the given slot.\n     *\n     * @param {HTMLElement} slot - Slot node\n     * @return {HTMLElement|false} The previous slot node or false.\n     */\n     getPrevious: function(slot) {\n        let previousSlot = slot.previousElementSibling;\n        while (previousSlot) {\n            if (previousSlot.matches(this.SELECTORS.SLOT)) {\n                return previousSlot;\n            }\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Returns the previous numbered slot to the given slot.\n     * Ignores slots containing description question types.\n     *\n     * @method getPrevious\n     * @param slot {Element} Slot node\n     * @return {Element|false} The previous slot node or false.\n     */\n    getPreviousNumbered(slot) {\n        let previous = slot.previousElementSibling;\n        while (previous) {\n            if (!previous.matches(this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')')) {\n                previous = previous.previousElementSibling;\n            } else {\n                return previous;\n            }\n        }\n\n        let section = slot.closest('li.section').previousElementSibling;\n        while (section) {\n            const questions = section.querySelectorAll(this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')');\n            if (questions.length > 0) {\n                return questions[questions.length - 1];\n            }\n            section = section.previousElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Reset the order of the numbers given to each slot.\n     *\n     * @method reorderSlots\n     * @return void\n     */\n    reorderSlots() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach(slot => {\n            if (!page.getPageFromSlot(slot)) {\n                // Move the next page to the front.\n                const nextPage = slot.nextElementSibling;\n                slot.parentNode.insertBefore(nextPage, slot);\n            }\n\n            const previousSlot = this.getPreviousNumbered(slot);\n            let previousSlotNumber = 0;\n\n            if (slot.classList.contains(this.CSS.QUESTIONTYPEDESCRIPTION)) {\n                return;\n            }\n\n            if (previousSlot) {\n                previousSlotNumber = this.getNumber(previousSlot);\n            }\n\n            // Set slot number.\n            this.setNumber(slot, previousSlotNumber + 1);\n        });\n    },\n\n    /**\n     * Add class only-has-one-slot to those sections that need it.\n     *\n     * @method updateOneSlotSections\n     * @return void\n     */\n    updateOneSlotSections() {\n        document.querySelectorAll('.mod-quiz-edit-content ul.slots li.section').forEach(section => {\n            if (section.querySelectorAll(this.SELECTORS.SLOT).length > 1) {\n                section.classList.remove('only-has-one-slot');\n            } else {\n                section.classList.add('only-has-one-slot');\n            }\n        });\n    },\n\n    /**\n     * Remove a slot and related elements from the list of slots.\n     *\n     * @method remove\n     * @param slot {Element} Slot node.\n     * @return void\n     */\n    remove: function(slot) {\n        const pageElement = page.getPageFromSlot(slot);\n        slot.remove();\n\n        // Is the page empty.\n        if (!page.isEmpty(pageElement)) {\n            return;\n        }\n        // If so remove it. Including add menu and page break.\n        page.remove(pageElement, false);\n    },\n\n    /**\n     * Returns a list of all page break elements on the page.\n     *\n     * @method getPageBreaks\n     * @return {Element[]} An array containing page break nodes.\n     */\n    getPageBreaks() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + this.SELECTORS.PAGEBREAK;\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Retrieve the page break element item from the given slot.\n     *\n     * @method getPageBreak\n     * @param slot {Element} Slot node\n     * @return {Element|null} The Page Break Node.\n     */\n    getPageBreak: function(slot) {\n        return slot.querySelector(this.SELECTORS.PAGEBREAK);\n    },\n\n    /**\n     * Add a page break and related elements to the list of slots.\n     *\n     * @method addPageBreak\n     * @param slot {Element} Slot node.\n     * @return pagebreak PageBreak node\n     */\n    addPageBreak(slot) {\n        let nodeText = config.addpageiconhtml;\n        nodeText = nodeText.replace('%%SLOT%%', this.getNumber(slot));\n        let pageBreak = document.createElement('div');\n        pageBreak.innerHTML = nodeText;\n        slot.querySelector('div').insertAdjacentElement('afterend', pageBreak);\n        return pageBreak;\n    },\n\n    /**\n     * Remove a pagebreak from the given slot.\n     *\n     * @method removePageBreak\n     * @param slot {Element} Slot node.\n     * @return boolean\n     */\n    removePageBreak: function(slot) {\n        const pageBreak = this.getPageBreak(slot);\n        if (!pageBreak) {\n            return false;\n        }\n        pageBreak.remove();\n        return true;\n    },\n\n    /**\n     * Reorder each pagebreak by iterating through each related slot.\n     *\n     * @method reorderPageBreaks\n     * @return void\n     */\n    reorderPageBreaks: function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n\n        slots.forEach((slot, key) => {\n            slotNumber++;\n            let pageBreak = this.getPageBreak(slot);\n            const nextItem = slot.nextElementSibling && slot.nextElementSibling.matches('li.activity')\n                ? slot.nextElementSibling : null;\n            if (!nextItem) {\n                // Last slot in a section. Should not have an icon.\n                return;\n            }\n\n            // No pagebreak and not last slot. Add one.\n            if (!pageBreak) {\n                pageBreak = this.addPageBreak(slot);\n            }\n\n            // Remove last page break if there is one.\n            if (pageBreak && key === slots.length - 1) {\n                this.removePageBreak(slot);\n            }\n\n            // Get page break anchor element.\n            const pageBreakLink = pageBreak.firstElementChild;\n\n            // Get the correct title.\n            let action = '';\n            let iconName = '';\n            if (page.isPage(nextItem)) {\n                action = 'removepagebreak';\n                iconName = 'e/remove_page_break';\n            } else {\n                action = 'addpagebreak';\n                iconName = 'e/insert_page_break';\n            }\n\n            // Update the link and image titles\n            pageBreakLink.title = M.util.get_string(action, 'quiz');\n            pageBreakLink.dataset.action = action;\n\n            // Update the image title.\n            const icon = pageBreakLink.querySelector(this.SELECTORS.ICON);\n            icon.title = M.util.get_string(action, 'quiz');\n            icon.alt = M.util.get_string(action, 'quiz');\n\n            // Update the image src.\n            icon.src = M.util.image_url(iconName);\n\n            // Get anchor url parameters as an associative array.\n            const params = new URLSearchParams(pageBreakLink.href);\n            // Update slot number.\n            params.set('slot', slotNumber + '');\n            // Update the anchor.\n            pageBreakLink.href = `${pageBreakLink.href.split('?')[0]}?${params.toString()}`;\n        });\n    },\n\n    /**\n     * Update the dependency icons.\n     *\n     * @method updateAllDependencyIcons\n     * @return void\n     */\n     updateAllDependencyIcons: function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n        let previousSlot = null;\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach(slot => {\n            slotNumber++;\n\n            const dependencyWrapper = slot.querySelector(this.SELECTORS.DEPENDENCY_WRAPPER);\n            if (slotNumber === 1 || previousSlot?.dataset.canfinish === '0') {\n                dependencyWrapper.classList.add(this.CSS.CANNOT_DEPEND);\n            } else {\n                dependencyWrapper.classList.remove(this.CSS.CANNOT_DEPEND);\n            }\n            this.updateDependencyIcon(slot, null);\n\n            previousSlot = slot;\n        });\n    },\n\n    /**\n     * Update the slot icon to indicate the new requiresPrevious state.\n     *\n     * @param {HTMLElement} slot - Slot node\n     * @param {boolean|null} requiresPrevious - Whether this node now requires the previous one.\n     * @return void\n     */\n    updateDependencyIcon: function(slot, requiresPrevious) {\n        const link = slot.querySelector(this.SELECTORS.DEPENDENCY_LINK);\n        const icon = slot.querySelector(this.SELECTORS.DEPENDENCY_ICON);\n        const previousSlot = this.getPrevious(slot);\n        const a = {thisq: this.getNumber(slot)};\n\n        if (previousSlot) {\n            a.previousq = this.getNumber(previousSlot);\n        }\n\n        if (requiresPrevious === null) {\n            requiresPrevious = link.dataset.action === 'removedependency';\n        }\n\n        if (requiresPrevious) {\n            link.title = M.util.get_string('questiondependencyremove', 'quiz', a);\n            link.dataset.action = 'removedependency';\n            Templates.renderPix('t/locked', 'core', M.util.get_string('questiondependsonprevious', 'quiz'))\n                .then((html) => {\n                    icon.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        } else {\n            link.title = M.util.get_string('questiondependencyadd', 'quiz', a);\n            link.dataset.action = 'adddependency';\n            Templates.renderPix('t/unlocked', 'core', M.util.get_string('questiondependencyfree', 'quiz'))\n                .then((html) => {\n                    icon.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        }\n    },\n};\n\nconst page = {\n    CSS: {\n        PAGE: 'page'\n    },\n    CONSTANTS: {\n        ACTIONMENUIDPREFIX: 'action-menu-',\n        ACTIONMENUBARIDSUFFIX: '-menubar',\n        ACTIONMENUMENUIDSUFFIX: '-menu',\n        PAGEIDPREFIX: 'page-',\n        PAGENUMBERPREFIX: getString('page', 'moodle') + ' '\n    },\n    SELECTORS: {\n        ACTIONMENU: 'div.moodle-actionmenu',\n        ACTIONMENUBAR: '.menubar',\n        ACTIONMENUMENU: '.menu',\n        ADDASECTION: '[data-action=\"addasection\"]',\n        PAGE: 'li.page',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'h4'\n    },\n\n    /**\n     * Retrieve the page item from one of its child Nodes.\n     *\n     * @param {HTMLElement} pageComponent - The component Node.\n     * @return {HTMLElement|null} The Page Node.\n     */\n    getPageFromComponent: function(pageComponent) {\n        return pageComponent.closest(this.SELECTORS.PAGE);\n    },\n\n    /**\n     * Retrieve the page item from one of its previous siblings.\n     *\n     * @method getPageFromSlot\n     * @param slot {Element} The component Node.\n     * @return {Element|null} The Page Node.\n     */\n    getPageFromSlot: function(slot) {\n        let previousElement = slot.previousElementSibling;\n        while (previousElement) {\n            if (previousElement.matches(this.SELECTORS.PAGE)) {\n                return previousElement;\n            }\n            previousElement = previousElement.previousElementSibling;\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns the page ID for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find an ID for.\n     * @return {Number|false} The ID of the page in question or false if no ID was found.\n     */\n    getId: function(page) {\n        // We perform a simple substitution operation to get the ID.\n        let id = page.id.replace(this.CONSTANTS.PAGEIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (!isNaN(id) && isFinite(id)) {\n            return id;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page id for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} id - The id value.\n     * @return void\n     */\n    setId: function(page, id) {\n        page.id = `${this.CONSTANTS.PAGEIDPREFIX}${id}`;\n    },\n\n    /**\n     * Determines the page name for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a name for.\n     * @return {string|null} The name of the page in question or null if no name was found.\n     */\n    getName: function(page) {\n        const instance = page.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance && instance.firstChild) {\n            return instance.firstChild.data ?? instance.firstChild;\n        }\n\n        return null;\n    },\n\n    /**\n     * Determines the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a number for.\n     * @return {number|false} The number of the page in question or false if no number was found.\n     */\n     getNumber: function(page) {\n        // We perform a simple substitution operation to get the number.\n        const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (!numberElement) {\n            return false;\n        }\n\n        let number = numberElement.textContent.replace(this.CONSTANTS.PAGENUMBERPREFIX, '');\n\n        // Attempt to validate the number.\n        number = parseInt(number, 10);\n        if (!isNaN(number) && isFinite(number)) {\n            return number;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} number - The number to set for the page.\n     * @return void\n     */\n    setNumber: function(page, number) {\n    const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (numberElement) {\n            numberElement.textContent = this.CONSTANTS.PAGENUMBERPREFIX + number;\n        }\n    },\n\n    /**\n     * Returns a list of all page elements.\n     *\n     * @return {HTMLElement[]} An array containing page nodes.\n     */\n    getPages: function() {\n        return [...document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.PAGE}`)];\n    },\n\n    /**\n     * Is the given element a page element?\n     *\n     * @param {HTMLElement} page - Page node\n     * @return {boolean}\n     */\n    isPage: function(page) {\n        return page && page.classList.contains(this.CSS.PAGE);\n    },\n\n    /**\n     * Add a page and related elements to the list of slots.\n     *\n     * @param {HTMLElement|String} beforeNode - Element to add before.\n     * @return {HTMLElement} - Page node\n     */\n    add: function(beforeNode) {\n        const pageFromSlot = this.getPageFromSlot(beforeNode);\n        const pageNumber = this.getNumber(pageFromSlot) + 1;\n        const pageHtml = config.pagehtml;\n\n        // Normalize the page number.\n        const pageHtmlWithNumber = pageHtml.replace(/%%PAGENUMBER%%/g, pageNumber);\n\n        // Create the page node.\n        const page = document.createElement('div');\n        page.innerHTML = pageHtmlWithNumber;\n        const pageNode = page.firstElementChild;\n\n        // Assign it as a drop target.\n        // YUI().use('dd-drop', function(Y) {\n        //     const drop = new Y.DD.Drop({\n        //         node: pageNode,\n        //         groups: M.mod_quiz.dragres.groups\n        //     });\n        //     pageNode.drop = drop;\n        // });\n\n        // Insert in the correct place.\n        beforeNode.insertAdjacentElement('afterend', pageNode);\n\n        // Enhance the add menu to make if fully visible and clickable.\n        if (typeof M.core.actionmenu !== 'undefined') {\n            M.core.actionmenu.newDOMNode(pageNode);\n        }\n\n        return pageNode;\n    },\n\n    /**\n     * Does the page have at least one slot?\n     *\n     * @method isEmpty\n     * @param page {Element} Page node\n     * @return boolean\n     */\n    isEmpty: function(page) {\n        let activity = page.nextElementSibling;\n        while (activity && !activity.matches('li.activity')) {\n            activity = activity.nextElementSibling;\n        }\n        if (!activity) {\n            return true;\n        }\n        return !activity.classList.contains('slot');\n    },\n\n    /**\n     * Remove a page and related elements from the list of slots.\n     *\n     * @method remove\n     * @param page {Element} Page node.\n     * @param keepPageBreak {boolean} Keep page break flag.\n     * @return void\n     */\n    remove: function(page, keepPageBreak) {\n        // Remove page break from previous slot.\n        let previousSlot = page.previousElementSibling;\n        while (previousSlot && !previousSlot.matches(slot.SELECTORS.SLOT)) {\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        if (!keepPageBreak && previousSlot) {\n            slot.removePageBreak(previousSlot);\n        }\n        page.remove();\n    },\n\n    /**\n     * Reset the order of the numbers given to each page.\n     *\n     * @return void\n     */\n    reorderPages: function() {\n        const pages = this.getPages();\n        let currentPageNumber = 0;\n        pages.forEach((page) => {\n            if (this.isEmpty(page)) {\n                const keepPageBreak = page.nextElementSibling.classList.contains('slot');\n                this.remove(page, keepPageBreak);\n                return;\n            }\n\n            currentPageNumber++;\n            this.setNumber(page, currentPageNumber);\n            this.setId(page, currentPageNumber);\n        });\n\n        this.reorderActionMenus();\n    },\n    /**\n     * Reset the order of the numbers given to each action menu.\n     *\n     * @return void\n     */\n    reorderActionMenus: function() {\n        const actionMenus = this.getActionMenus();\n        actionMenus.forEach((actionMenu, index) => {\n            const previousActionMenu = actionMenus[index - 1];\n            const previousActionMenuNumber = previousActionMenu ? this.getActionMenuId(previousActionMenu) : 0;\n            const id = previousActionMenuNumber + 1;\n\n            this.setActionMenuId(actionMenu, id);\n\n            const menuBar = actionMenu.querySelector(this.SELECTORS.ACTIONMENUBAR);\n            menuBar.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUBARIDSUFFIX}`;\n\n            const menuMenu = actionMenu.querySelector(this.SELECTORS.ACTIONMENUMENU);\n            menuMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUMENUIDSUFFIX}`;\n\n            const addSectionLink = menuMenu.querySelector(this.SELECTORS.ADDASECTION);\n            addSectionLink.href = addSectionLink.href.replace(/\\baddsectionatpage=\\d+\\b/, `addsectionatpage=${id}`);\n        });\n    },\n\n    /**\n     * Returns a list of all action menu elements.\n     *\n     * @return {HTMLElement[]} An array containing action menu nodes.\n     */\n    getActionMenus: function() {\n        return Array.from(\n            document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.ACTIONMENU}`)\n        );\n    },\n\n    /**\n     * Returns the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to find an ID for.\n     * @return {number|false} The ID of the action menu in question or false if no ID was found.\n     */\n    getActionMenuId: function(actionMenu) {\n        const id = actionMenu.id.replace(this.CONSTANTS.ACTIONMENUIDPREFIX, '');\n        const parsedId = parseInt(id, 10);\n        return !isNaN(parsedId) && isFinite(parsedId) ? parsedId : false;\n    },\n\n    /**\n     * Updates the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to update the ID for.\n     * @param {number} id - The ID value.\n     * @return void\n     */\n    setActionMenuId: function(actionMenu, id) {\n        actionMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}`;\n    },\n};\n\nconst util = {\n    /**\n     * Appends a hidden spinner element to the specified node.\n     *\n     * @param {Element} node The node the spinner should be added to\n     * @return {Element} created spinner node\n     */\n    addSpinner: function(node) {\n        const WAITICON = {'pix': \"i/loading_small\", 'component': 'moodle'};\n\n        // Check if spinner is already there\n        const currentSpinner = node.querySelector('.spinner');\n        if (currentSpinner) {\n            return currentSpinner;\n        }\n\n        const spinner = this.createElement('img', {\n            src: M.util.image_url(WAITICON.pix, WAITICON.component),\n            \"class\": 'spinner iconsmall d-none',\n        });\n        node.append(spinner);\n\n        return spinner;\n    },\n\n    createElement: function(tag, attributes) {\n        const element = document.createElement(tag);\n        for (let key in attributes) {\n            element.setAttribute(key, attributes[key]);\n        }\n\n        return element;\n    }\n};\n\nexport {\n    slot,\n    util,\n    page,\n};"],"names":["slot","CSS","SLOT","QUESTIONTYPEDESCRIPTION","CANNOT_DEPEND","CONSTANTS","SLOTIDPREFIX","QUESTION","M","util","get_string","SELECTORS","INSTANCENAME","NUMBER","PAGECONTENT","PAGEBREAK","ICON","SECTIONUL","DEPENDENCY_WRAPPER","DEPENDENCY_LINK","DEPENDENCY_ICON","getSlotFromComponent","slotComponent","closest","this","getId","id","replace","parseInt","isFinite","getName","instance","querySelector","firstChild","data","getNumber","number","textContent","isNaN","setNumber","innerHTML","getSlots","document","querySelectorAll","getNumberedSlots","selector","getPrevious","previousSlot","previousElementSibling","matches","getPreviousNumbered","previous","section","questions","length","reorderSlots","forEach","page","getPageFromSlot","nextPage","nextElementSibling","parentNode","insertBefore","previousSlotNumber","classList","contains","updateOneSlotSections","remove","add","pageElement","isEmpty","getPageBreaks","getPageBreak","addPageBreak","nodeText","config","addpageiconhtml","pageBreak","createElement","insertAdjacentElement","removePageBreak","reorderPageBreaks","slots","slotNumber","key","nextItem","pageBreakLink","firstElementChild","action","iconName","isPage","title","dataset","icon","alt","src","image_url","params","URLSearchParams","href","set","split","toString","updateAllDependencyIcons","dependencyWrapper","canfinish","updateDependencyIcon","requiresPrevious","link","a","thisq","previousq","renderPix","then","html","catch","Notification","exception","PAGE","ACTIONMENUIDPREFIX","ACTIONMENUBARIDSUFFIX","ACTIONMENUMENUIDSUFFIX","PAGEIDPREFIX","PAGENUMBERPREFIX","ACTIONMENU","ACTIONMENUBAR","ACTIONMENUMENU","ADDASECTION","getPageFromComponent","pageComponent","previousElement","setId","numberElement","getPages","beforeNode","pageFromSlot","pageNumber","pageHtmlWithNumber","pagehtml","pageNode","core","actionmenu","newDOMNode","activity","keepPageBreak","reorderPages","pages","currentPageNumber","reorderActionMenus","actionMenus","getActionMenus","actionMenu","index","previousActionMenu","getActionMenuId","setActionMenuId","menuMenu","addSectionLink","Array","from","parsedId","addSpinner","node","WAITICON","currentSpinner","spinner","append","tag","attributes","element","setAttribute"],"mappings":"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"}